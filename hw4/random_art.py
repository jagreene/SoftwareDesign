# -*- coding: utf-8 -*-
"""
Created on Tue Feb 11 11:34:57 2014

@author: pruvolo
"""

# you do not have to use these particular modules, but they may help
from random import randint, random
import math
import Image

def build_random_function(min_depth, max_depth):
    '''This function generates nested lists of random functions. The nest will be atleast as deep as the min_depth and no deeper than the max_depth.
        Whether or not the function stops at a depth between the two is determined by a random failure chance in the recurcsion condition. The actual
        functions making up the list are determined by using a random number generator to choose function entries in an associated dictionary.
    '''

    options = {
    1 : "cos_pi",
    2 : "sin_pi",
    3 : "squared",
    4 : "atan_pi",
    5 : "prod",
    }

    if min_depth > 0 or (max_depth > 0 and randint(0,10) > 5):
        picker = randint(1,5);
        picked_function = options[picker]
        if picker <=4:
            return [picked_function, build_random_function(min_depth-1,max_depth-1)]
        else:
            return [picked_function, build_random_function(min_depth-1, max_depth-1), build_random_function(min_depth-1,max_depth-1)]

    else:
        if randint(1,2) == 1:
            return ["X"]
        else:
            return ["Y"]

def build_random_function_unit_test():
    ''' This is a simple unit test to see the output of the build_random_function() function'''
    print build_random_function(3,5)

def build_random_lambda_function(min_depth, max_depth):
    ''' This is the same as build_random_function but instead of outputing a nested list it outputs an anonomous function which can be easily accessed by other functions. Its also
        works by using a random number generator and a dicitionary of associated functions that recursively create the lamda functions.
    '''

    def cos_pi():
        return lambda x,y: math.cos(math.pi*(build_random_lambda_function(min_depth-1,max_depth-1)(x,y)))
    def sin_pi():
        return lambda x,y: math.sin(math.pi*(build_random_lambda_function(min_depth-1,max_depth-1)(x,y)))
    def squared():
        return lambda x,y: (build_random_lambda_function(min_depth-1,max_depth-1)(x,y))**2
    def atan_pi():
        return lambda x,y: math.atan(math.pi*(build_random_lambda_function(min_depth-1,max_depth-1)(x,y)))
    def prod():
        return lambda x,y: (build_random_lambda_function(min_depth-1,max_depth-1)(x,y))*(build_random_lambda_function(min_depth-1,max_depth-1)(x,y))

    options = {
    1 : cos_pi,
    2 : sin_pi,
    3 : squared,
    4 : atan_pi,
    5 : prod
    }

    if min_depth > 0 or (max_depth > 0 and randint(0,10) > 5):
        picker = randint(1,5);
        return options[picker]()
    else:
        if randint(1,2) == 1:
            return lambda x,y: x
        else:
            return lambda x,y: y

def build_random_lambda_function_unit_test():
    '''Prints the output of build_random_lambda_function'''
    f = build_random_lambda_function(1,1)
    print f(1,1)

def evaluate_random_function(f, x, y):
    '''This takes as input arguements a nested list generated by build_random_function and an x and a y value to solve said list with. The code recursively evaluates
        each function in turn.
    '''

    def cos_pi():
        return math.cos(math.pi*evaluate_random_function(f[1],x,y))
    def sin_pi():
        return math.sin(math.pi*evaluate_random_function(f[1],x,y))
    def squared():
        return evaluate_random_function(f[1],x,y)**2
    def atan_pi():
        return math.atan(math.pi*evaluate_random_function(f[1],x,y))
    def prod():
        return evaluate_random_function(f[1],x,y)*evaluate_random_function(f[2],x,y)
    def X():
        return x
    def Y():
        return y

    operations = {
    "cos_pi" : cos_pi,
    "sin_pi" : sin_pi,
    "squared": squared,
    "atan_pi": atan_pi,
    "prod"   : prod, 
    "X"      : X,
    "Y"      : Y,
    }

    return operations[f[0]]()

def evaluate_random_function_unit_test():
    ''' This test creates a random function list, and an x and y value to evaluate it with. The output is then printed, and the user can check if it is right'''
    X = random()
    Y = random()
    f = build_random_function(2,3)

    print evaluate_random_function(f, X, Y)

def Create_Art():
    '''This function creates three functions for each of the color channels and then evaluates it for each pixel based on the pixel's x and y coordinates'''
    def remap_interval(val, input_interval_start, input_interval_end, output_interval_start, output_interval_end):
        """ Maps the input value that is in the interval [input_interval_start, input_interval_end]
            to the output interval [output_interval_start, output_interval_end].  The mapping
            is an affine one (i.e. output = input*c + b).
        
            The mapping is simply a linear conversion between the two ranges, and is found using simple point slope form
        """

        input_range = float(input_interval_end - input_interval_start)
        output_range = float(output_interval_end - output_interval_start)

        slope = output_range/input_range

        final_value = slope * (val - input_interval_end) + output_interval_end
        return final_value

    image = Image.new("RGB",(350,350))
    pix = image.load()
    r_func = build_random_function(3,5)
    g_func = build_random_function(3,5)
    b_func = build_random_function(3,5)

    for xPixels in xrange(0, 350):
        for yPixels  in xrange(0,350):
            adjusted_x = remap_interval(xPixels, 0, 349,-1,1)
            adjusted_y = remap_interval(yPixels, 0, 349,-1,1)
            rValue = int(remap_interval(evaluate_random_function(r_func, adjusted_x, adjusted_y), -1,1,0,255))
            gValue = int(remap_interval(evaluate_random_function(b_func, adjusted_x, adjusted_y), -1,1,0,255))
            bValue = int(remap_interval(evaluate_random_function(g_func, adjusted_x, adjusted_y), -1,1,0,255))

            value = (rValue,gValue,bValue)
            pix[xPixels, yPixels] =  value

    image.save("my_art.png")

def Create_Lambda_Art():
    '''This function creates three lambda functions for each of the color channels and then evaluates it for each pixel based on the pixel's x and y coordinates'''

    def remap_interval(val, input_interval_start, input_interval_end, output_interval_start, output_interval_end):
        """ Maps the input value that is in the interval [input_interval_start, input_interval_end]
            to the output interval [output_interval_start, output_interval_end].  The mapping
            is an affine one (i.e. output = input*c + b).
        
            The mapping is simply a linear conversion between the two ranges, and is found using simple point slope form
        """

        input_range = float(input_interval_end - input_interval_start)
        output_range = float(output_interval_end - output_interval_start)

        slope = output_range/input_range

        final_value = slope * (val - input_interval_end) + output_interval_end
        return final_value

    image = Image.new("RGB",(350,350))
    pix = image.load()
    r_func = build_random_lambda_function(3,5)
    g_func = build_random_lambda_function(3,5)
    b_func = build_random_lambda_function(3,5)

    for xPixels in xrange(0, 350):
        for yPixels  in xrange(0,350):
            adjusted_x = remap_interval(xPixels, 0, 349,-1,1)
            adjusted_y = remap_interval(yPixels, 0, 349,-1,1)
            rValue = int(remap_interval(r_func (adjusted_x, adjusted_y), -1,1,0,255))
            gValue = int(remap_interval(b_func (adjusted_x, adjusted_y), -1,1,0,255))
            bValue = int(remap_interval(g_func (adjusted_x, adjusted_y), -1,1,0,255))

            value = (rValue,gValue,bValue)
            pix[xPixels, yPixels] =  value

    image.save("my_art.png")

Create_Art()
print "ROCKING EVERYWHERE!!!!!"